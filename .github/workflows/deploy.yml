name: Release (Build & Deploy)

# Сборка и деплой выполняются только при создании релизного тега v* (например v1.0.0).
# См. docs/branching-model.md и docs/deployment-yandex-cloud.md.
on:
  push:
    tags: ["v*"]

env:
  CR_REGISTRY: cr.yandex/${{ secrets.YC_REGISTRY_ID }}
  RELEASE_TAG: ${{ github.ref_name }}

jobs:
  # ==========================================
  # 1. Запуск тестов (параллельно)
  # ==========================================
  test-auth-service:
    name: Auth Service Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: projects/backend/services/auth-service
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install PostgreSQL
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends postgresql
      - uses: snok/install-poetry@v1
        with:
          version: 1.8.3
      - run: poetry install --no-interaction --no-root
      - run: poetry run pytest -q

  test-experiment-service:
    name: Experiment Service Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: projects/backend/services/experiment-service
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install PostgreSQL + TimescaleDB
        run: |
          UBUNTU_CODENAME=$(lsb_release -cs)
          # Use PGDG for postgresql-16 >= 16.13 (TimescaleDB loader requires it; Ubuntu has 16.12).
          curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | \
            sudo gpg --dearmor -o /usr/share/keyrings/pgdg.gpg
          echo "deb [signed-by=/usr/share/keyrings/pgdg.gpg] https://apt.postgresql.org/pub/repos/apt ${UBUNTU_CODENAME}-pgdg main" \
            | sudo tee /etc/apt/sources.list.d/pgdg.list
          echo "deb https://packagecloud.io/timescale/timescaledb/ubuntu/ ${UBUNTU_CODENAME} main" \
            | sudo tee /etc/apt/sources.list.d/timescaledb.list
          curl -sL https://packagecloud.io/timescale/timescaledb/gpgkey | \
            gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/timescaledb.gpg >/dev/null
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends postgresql-16
          sudo apt-get install -y --no-install-recommends timescaledb-2-postgresql-16
      - uses: snok/install-poetry@v1
        with:
          version: 1.8.3
      - run: poetry install --no-interaction --no-root
      - name: Configure TimescaleDB for testsuite
        run: |
          PG_CONF=$(poetry run python -c "
          import testsuite.databases.pgsql.service as s
          print(s.CONFIGS_DIR / 'postgresql.conf')
          ")
          echo "shared_preload_libraries = 'timescaledb'" >> "$PG_CONF"
      - run: poetry run pytest -q

  test-frontend:
    name: Frontend Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: projects/frontend/apps/experiment-portal
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
      - run: npm ci
      - run: npm test -- --run

  # ==========================================
  # 2. Сборка и пуш Docker-образов
  # ==========================================
  build-and-push:
    name: Build & Push Images
    needs: [test-auth-service, test-experiment-service, test-frontend]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - service: auth-service
            context: ./projects/backend
            dockerfile: services/auth-service/Dockerfile
          - service: experiment-service
            context: ./projects/backend
            dockerfile: services/experiment-service/Dockerfile
          - service: telemetry-ingest-service
            context: ./projects/backend
            dockerfile: services/telemetry-ingest-service/Dockerfile
          - service: auth-proxy
            context: ./projects/frontend/apps/auth-proxy
            dockerfile: Dockerfile
          - service: experiment-portal
            context: ./projects/frontend/apps/experiment-portal
            dockerfile: Dockerfile
          - service: sensor-simulator
            context: ./projects/frontend/apps/sensor-simulator
            dockerfile: Dockerfile
    steps:
      - uses: actions/checkout@v4

      - name: Login to Yandex Container Registry
        uses: docker/login-action@v3
        with:
          registry: cr.yandex
          username: json_key
          password: ${{ secrets.YC_SA_JSON_KEY }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.CR_REGISTRY }}/${{ matrix.service }}
          tags: |
            type=raw,value=${{ env.RELEASE_TAG }}
            type=raw,value=latest

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.context }}/${{ matrix.dockerfile }}
          target: production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================
  # 3. Деплой на VM
  # ==========================================
  deploy:
    name: Deploy to VM
    needs: [build-and-push]
    runs-on: ubuntu-latest
    environment: production
    concurrency:
      group: deploy-production
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        env:
          IMAGE_TAG: ${{ env.RELEASE_TAG }}
          CR_REGISTRY: ${{ env.CR_REGISTRY }}
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_PRIVATE_KEY }}
          envs: IMAGE_TAG,CR_REGISTRY
          script: |
            set -euo pipefail
            cd /opt/experiment-tracking

            # Обновляем тег образа
            sed -i "s|^IMAGE_TAG=.*|IMAGE_TAG=${IMAGE_TAG}|" .env

            # Логинимся в Container Registry
            yc container registry configure-docker

            # Пуллим новые образы
            docker compose -f docker-compose.prod.yml pull

            # Запускаем с zero-downtime (по одному сервису)
            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            # Ждём health checks
            sleep 15

            # Проверяем статус
            docker compose -f docker-compose.prod.yml ps

            # Чистим старые образы
            docker image prune -f

      - name: Health check
        run: |
          for i in $(seq 1 10); do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.VM_HOST }}/") || true
            if [ "$STATUS" = "200" ]; then
              echo "Health check passed (attempt $i)"
              exit 0
            fi
            echo "Attempt $i: status=$STATUS, retrying in 10s..."
            sleep 10
          done
          echo "Health check failed after 10 attempts"
          exit 1

  # ==========================================
  # 4. Создание GitHub Release
  # ==========================================
  create-release:
    name: Create GitHub Release
    needs: [deploy]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: Release ${{ env.RELEASE_TAG }}
          generate_release_notes: true
          draft: false
