# Физика системы стабилизации RC-машины

Подробное описание физических принципов, математических моделей и алгоритмов, лежащих в основе системы стабилизации.

---

## 1. Модель RC-машины как твёрдого тела

### 1.1. Системы координат

Используем три системы координат:

**Инерциальная (Earth) — NED:**
- **N** (North) — вперёд по горизонту
- **E** (East) — вправо
- **D** (Down) — вниз (по гравитации)

**Кузовная (Body):**
- **x** — вперёд по оси машины (вдоль шасси)
- **y** — вправо
- **z** — вниз

**Датчиковая (Sensor):**
- Зависит от установки IMU на шасси
- Связь с кузовной определяется при калибровке (этап 2: определение `forward_vec`)

```
       Вид сверху (Body frame)

              x (вперёд)
              ↑
              |
     y ←------+  (центр масс)

       ψ (yaw) — вращение вокруг z (вниз)
```

### 1.2. Углы Эйлера

Ориентация кузова относительно Earth-frame описывается тремя углами:

| Угол | Ось вращения | Обозначение | Физический смысл |
|------|-------------|-------------|-----------------|
| **Roll** (крен) | x (вперёд) | φ | Наклон влево/вправо |
| **Pitch** (тангаж) | y (вправо) | θ | Наклон вперёд/назад (склон) |
| **Yaw** (рыскание) | z (вниз) | ψ | Направление движения |

Соответствующие угловые скорости:

| Скорость | Измерение | Использование |
|----------|-----------|---------------|
| ω_x (roll rate) | gyro X | Детекция опрокидывания |
| ω_y (pitch rate) | gyro Y | Движение по склону |
| **ω_z (yaw rate)** | **gyro Z** | **Главный сигнал для стабилизации** |

### 1.3. Что измеряет IMU

**MPU-6500** содержит два датчика:

**Гироскоп** (3 оси) — измеряет **угловую скорость** ω [°/с]:
```
ω_measured = ω_true + bias + noise
```
- `bias` — постоянное смещение (~1-5 °/с), устраняется калибровкой
- `noise` — случайный шум, устраняется фильтрацией (LPF)
- **Нет дрейфа по yaw** у ω_z — дрейфует только интеграл (угол ψ), но для yaw rate control нам нужна именно скорость, не угол

**Акселерометр** (3 оси) — измеряет **собственное ускорение** [g]:
```
a_measured = a_linear + g_projected + bias + noise
```
- `g_projected` — проекция гравитации на оси датчика (зависит от наклона)
- `a_linear` — линейное ускорение от движения
- В покое: `a_measured ≈ g_projected` → можно определить наклон (pitch, roll)
- **Нельзя определить yaw** из акселерометра (гравитация не зависит от поворота вокруг вертикали)

---

## 2. Оценка ориентации: фильтр Madgwick

### 2.1. Зачем нужен фильтр

Ни гироскоп, ни акселерометр по отдельности не дают хорошую оценку ориентации:

| Датчик | Достоинства | Недостатки |
|--------|-------------|------------|
| Гироскоп | Быстрый, точный на коротких интервалах | Дрейф при интегрировании |
| Акселерометр | Нет дрейфа, абсолютная привязка к гравитации | Шум, чувствительность к вибрациям и ускорениям |

Фильтр Madgwick **совмещает** оба источника: использует гироскоп для быстрого отслеживания поворотов и акселерометр для долгосрочной коррекции дрейфа.

### 2.2. Кватернионное представление

Ориентация описывается единичным кватернионом:

```
q = [q_w, q_x, q_y, q_z],    |q| = 1
```

Преимущества перед углами Эйлера:
- Нет gimbal lock (потери степени свободы при θ = ±90°)
- Компактное умножение (4 компоненты вместо матрицы 3×3)
- Числовая стабильность при нормализации

### 2.3. Алгоритм Madgwick (IMU, 6-DOF)

На каждом шаге (dt = 2 мс при 500 Гц):

**Шаг 1 — Интегрирование гироскопа:**

Производная кватерниона от угловой скорости:
```
q̇_gyro = 0.5 · q ⊗ [0, ω_x, ω_y, ω_z]
```
где ⊗ — кватернионное умножение. Это точная формула кинематики вращения.

**Шаг 2 — Коррекция по акселерометру (градиентный спуск):**

Идея: в покое акселерометр показывает [0, 0, 1] (гравитация вниз в NED). Если ориентация q правильная, то:
```
q* ⊗ [0, 0, 0, 1] ⊗ q ≈ [0, a_x, a_y, a_z]_normalized
```

Ошибка — разница между предсказанной и измеренной проекцией гравитации. Градиент этой ошибки:
```
∇f = J^T · f(q, a)
```
где:
- `f(q, a)` — функция ошибки (разница между предсказанной и измеренной гравитацией)
- `J` — якобиан f по q

**Шаг 3 — Объединение:**
```
q̇ = q̇_gyro - β · ∇f / |∇f|
```

**Шаг 4 — Интегрирование и нормализация:**
```
q(t+dt) = q(t) + q̇ · dt
q(t+dt) = q(t+dt) / |q(t+dt)|    ← обязательная нормализация
```

### 2.4. Параметр β (madgwick_beta)

Единственный настраиваемый параметр фильтра. Физический смысл:

```
β ≈ √(3/4) · σ_gyro
```

где σ_gyro — среднеквадратичный шум гироскопа [рад/с].

| β | Поведение | Когда использовать |
|---|-----------|-------------------|
| 0.01-0.05 | Почти чистый гироскоп, медленная коррекция | Малые вибрации, точный гироскоп |
| **0.05-0.15** | **Баланс** | **RC-машина, типичные условия** |
| 0.2-0.5 | Быстрая коррекция, но шумная ориентация | Сильные вибрации, нужна быстрая сходимость |
| 0.5-1.0 | Почти чистый акселерометр | Только начальная инициализация |

**Для RC-машины**: β = 0.1 — хороший старт. При сильных вибрациях от мотора уменьшить до 0.05-0.08 (чтобы вибрации не "протекали" через акселерометр).

### 2.5. Извлечение углов Эйлера из кватерниона

```
pitch (θ) = -arcsin(2(q_w·q_y - q_z·q_x))
roll  (φ) =  atan2(2(q_w·q_x + q_y·q_z), 1 - 2(q_x² + q_y²))
yaw   (ψ) =  atan2(2(q_w·q_z + q_x·q_y), 1 - 2(q_y² + q_z²))
```

**Важно**: yaw (ψ) из Madgwick без магнитометра **дрейфует**. Это нормально — для yaw rate control мы используем ω_z напрямую, а не интеграл ψ.

---

## 3. Фильтрация гироскопа: LPF Butterworth 2-го порядка

### 3.1. Зачем фильтровать gyro Z

Сырой сигнал гироскопа содержит:
- **Полезный сигнал**: реальное вращение машины (0-20 Гц для типичных маневров)
- **Вибрации мотора и шасси**: 50-200 Гц
- **Электрический шум**: > 100 Гц

Если подать нефильтрованный ω_z в ПИД-регулятор, шум усилится (особенно D-член) и руль будет дрожать.

### 3.2. Почему Butterworth

Фильтр Butterworth — максимально плоская АЧХ в полосе пропускания:

```
|H(f)|² = 1 / (1 + (f/f_c)^(2n))
```

Для 2-го порядка (n = 2):
- Скат **-12 дБ/октаву** (-40 дБ/декаду) после частоты среза
- **Нет пульсаций** в полосе пропускания (в отличие от Чебышева)
- Минимальная фазовая задержка для данного порядка

### 3.3. Цифровая реализация (билинейное преобразование)

Аналоговый прототип Butterworth 2-го порядка:
```
H(s) = 1 / (s² + √2·s + 1)    (нормированная, Q = 1/√2)
```

Билинейное преобразование s → z с предварительным варпингом:
```
K = tan(π · f_c / f_s)
```

Коэффициенты цифрового фильтра:
```
norm = 1 / (1 + √2·K + K²)

b₀ = K² · norm
b₁ = 2 · K² · norm
b₂ = K² · norm

a₁ = 2 · (K² - 1) · norm
a₂ = (1 - √2·K + K²) · norm
```

Рекуррентная формула (Direct Form I):
```
y[n] = b₀·x[n] + b₁·x[n-1] + b₂·x[n-2] - a₁·y[n-1] - a₂·y[n-2]
```

### 3.4. Выбор частоты среза

| f_c [Гц] | Подавление на 100 Гц | Задержка (при 10 Гц) | Применение |
|-----------|----------------------|----------------------|------------|
| 15 | -30 дБ | ~15 мс | Гладкая дорога, медленные манёвры |
| 20 | -28 дБ | ~12 мс | Плавное управление |
| **30** | **-21 дБ** | **~8 мс** | **По умолчанию** |
| 40 | -16 дБ | ~6 мс | Быстрые манёвры, мало вибраций |
| 50 | -12 дБ | ~5 мс | Спортивный режим |

**Компромисс**: чем ниже f_c, тем чище сигнал, но больше фазовая задержка. Для control loop на 500 Гц задержка 8 мс (30 Гц) — это 4 такта, приемлемо.

### 3.5. Фазовая задержка и её влияние

Фильтр вносит **фазовый сдвиг** — задержку реакции. Для 2-го порядка Butterworth:

```
φ(f) = -2 · arctan(f/f_c)    (приближение для f << f_s)
```

Групповая задержка (время запаздывания сигнала):
```
τ_group ≈ √2 / (2π · f_c)    [секунды]
```

Для f_c = 30 Гц: τ ≈ 7.5 мс. Это добавляется к задержке ПИД-регулятора, поэтому при настройке PID нужно учитывать эту задержку (снижать D-коэффициент или увеличивать f_c).

---

## 4. Калибровка IMU

### 4.1. Модель ошибок датчиков

**Гироскоп:**
```
ω_measured = S_g · ω_true + b_g + n_g
```
- `S_g` — матрица масштаба и кросс-осевых связей (≈ I, обычно игнорируем)
- `b_g` — bias (постоянное смещение), 1-10 °/с — **главная ошибка**
- `n_g` — белый шум

**Акселерометр:**
```
a_measured = S_a · (a_true + g) + b_a + n_a
```
- `S_a` — масштаб (≈ I)
- `b_a` — bias, 10-50 mg
- Главное: определить `g` в системе координат датчика → знаем наклон

### 4.2. Этап 1: калибровка в покое

Машина неподвижна → ω_true = 0, a_true = 0.

Собираем N семплов (N = 1000-2000):
```
b_g = mean(ω_measured[1..N])           ← bias гироскопа
g_sensor = mean(a_measured[1..N])       ← вектор гравитации в СК датчика
b_a = |g_sensor| - 1.0                 ← bias акселерометра (отклонение нормы от 1g)
```

Валидация:
```
var(ω) < 0.5 (°/с)²     ← машина действительно неподвижна
var(a) < 0.01 g²         ← нет вибраций
```

### 4.3. Этап 2: определение направления "вперёд"

Машина едет прямо → линейное ускорение направлено по оси x кузова.

```
a_linear = a_measured - g_sensor        ← убираем гравитацию
forward_vec = normalize(mean(a_linear)) ← направление "вперёд" в СК датчика
```

Это нужно для:
- Корректной инициализации Madgwick (знаем как датчик ориентирован на машине)
- Проекции ускорения на ось движения (для оценки скорости в Фазе 3)

### 4.4. Компенсация в реальном времени

При каждом чтении IMU:
```
ω_corrected = ω_measured - b_g
a_corrected = a_measured - b_a_vec
```

ZUPT (Zero-velocity Update): если обнаружена неподвижность (var(ω) < порог за последние 100 мс), обновляем bias гироскопа для компенсации температурного дрейфа.

---

## 5. Фаза 1: Контроль рыскания (Yaw Rate Control)

### 5.1. Физика проблемы

При движении RC-машины с высокой скоростью и резком повороте руля:

1. Задние колёса теряют сцепление → **избыточная поворачиваемость** (oversteer)
2. Машина начинает вращаться быстрее, чем хочет оператор
3. Без стабилизации: неконтролируемый разворот (spin)

Задача: ограничить реальную угловую скорость ω_z тем значением, которое соответствует команде руля.

### 5.2. Желаемая угловая скорость (Reference Model)

Из кинематической **bicycle model** (модель одноколёсного велосипеда):

```
                   v · tan(δ)
    ω_z_desired = ────────────
                       L
```

где:
- `v` — скорость машины [м/с]
- `δ` — угол поворота передних колёс [рад], пропорционален команде руля
- `L` — колёсная база [м] (расстояние между осями)

**Проблема**: у нас нет датчика скорости v. Упрощение:

```
ω_z_desired = K_steer · steer_command
```

где `K_steer` — коэффициент, определяемый экспериментально. При steer_command = 0 (прямо) желаемая ω_z = 0.

**На первой итерации** можно использовать ещё проще: при `steer_command ≈ 0` (около нуля, мёртвая зона) желаемая ω_z = 0. Это уже даёт хорошую стабилизацию на прямой.

### 5.3. ПИД-регулятор

Ошибка:
```
e(t) = ω_z_desired - ω_z_filtered
```

Управляющее воздействие (коррекция руля):
```
                                 de(t)
u(t) = Kp·e(t) + Ki·∫e(τ)dτ + Kd·─────
                                  dt
```

В дискретной форме (500 Гц, dt = 2 мс):

```
P = Kp · e[n]
I = I_prev + Ki · e[n] · dt         (с anti-windup ограничением)
D = Kd · (e[n] - e[n-1]) / dt       (или D от измерения, не ошибки)
u[n] = P + I + D
```

Итоговая команда руля:
```
steer_output = steer_command + clamp(u[n], -max_correction, +max_correction)
```

### 5.4. Роль каждого члена ПИД

| Член | Что делает | Настройка для RC |
|------|-----------|------------------|
| **P** (пропорциональный) | Реагирует на текущую ошибку. Больше Kp → сильнее реакция | Основной. Начать с малого, увеличивать до появления колебаний, затем уменьшить на 30% |
| **I** (интегральный) | Компенсирует постоянное смещение (например, увод руля) | Обычно маленький или 0. Нужен, если машину постоянно тянет в сторону |
| **D** (дифференциальный) | Демпфирует колебания, реагирует на скорость изменения ошибки | Критичен для подавления осцилляций. Но усиливает шум → поэтому нужен LPF |

### 5.5. Anti-windup

Интегральный член может "накопить" большое значение, если ошибка долго не устраняется (например, машина застряла). При разблокировке руль резко дёрнет.

Решение — ограничение интеграла:
```
I = clamp(I, -I_max, +I_max)
```

Дополнительно: обнуление I при выключении стабилизации или переключении режима.

### 5.6. D-фильтрация (Derivative on Measurement)

Классический D-член усиливает шум, т.к. берёт производную ошибки. Решения:

**Вариант A**: Фильтрованный D
```
D_filtered = α · D_prev + (1-α) · D_raw    (α = 0.8-0.95)
```

**Вариант B**: D от измерения (а не ошибки)
```
D = -Kd · (ω_z[n] - ω_z[n-1]) / dt
```
Знак минус, потому что мы дифференцируем измерение, а не ошибку. Это эквивалентно при постоянном setpoint, но не усиливает ступенчатые изменения setpoint.

В нашем случае ω_z уже прошёл через LPF Butterworth → шум значительно подавлен, поэтому Вариант B предпочтителен.

### 5.7. Ограничение коррекции (Safety Limit)

```
max_correction = 0.3    (30% от полного хода руля)
```

Даже при максимальной ошибке коррекция руля не превышает 30%. Это:
- Предотвращает резкие рывки при сбоях
- Оставляет оператору контроль
- Позволяет безопасно настраивать ПИД

### 5.8. Блок-схема Фазы 1

```
steer_command ──────────────────┐
         │                      │
         ▼                      ▼
    ω_z_desired           steer_output
    = K · steer        = steer_cmd + u
         │                      ▲
         ▼                      │
      ┌──────┐             clamp(u)
  e = │  -   │◄── ω_z_filt     │
      └──┬───┘                  │
         │                      │
         ▼                      │
    ┌─────────┐                 │
    │   PID   │────────────────►│
    │ Kp,Ki,Kd│
    └─────────┘

    ω_z_filt ◄── LPF Butterworth ◄── gyro_z_calibrated ◄── IMU
```

---

## 6. Фаза 2: Компенсация наклона (Pitch/Roll)

### 6.1. Физика проблемы

При движении по склону:

**Подъём (pitch > 0):**
- Составляющая гравитации тормозит машину: `F_gravity = m·g·sin(θ)`
- Без компенсации машина замедляется и может остановиться
- Нужно увеличить газ пропорционально sin(θ)

**Спуск (pitch < 0):**
- Гравитация ускоряет машину
- Нужно уменьшить газ (или добавить торможение)

**Боковой наклон (roll ≠ 0):**
- Боковая составляющая гравитации: `F_lateral = m·g·sin(φ)`
- Машину тянет в сторону наклона
- Опционально: коррекция руля для компенсации

### 6.2. Алгоритм компенсации

Pitch и roll берём из Madgwick (уже реализован в Фазе 0):

```
throttle_correction = K_pitch · sin(pitch)
throttle_output = throttle_command + clamp(throttle_correction, -0.3, +0.3)
```

Для малых углов (< 20°): sin(θ) ≈ θ [рад], но лучше использовать точный sin — у ESP32-S3 есть FPU.

### 6.3. Отделение наклона от ускорения

Ключевая проблема: акселерометр не различает гравитацию и ускорение движения. При разгоне машины акселерометр "видит" наклон назад, хотя машина на ровной поверхности.

Фильтр Madgwick частично решает эту проблему:
- β контролирует, насколько быстро акселерометр корректирует ориентацию
- При малом β (0.05-0.1) кратковременные ускорения не влияют на оценку pitch/roll
- Длительный подъём (> 1-2 с) корректно определяется

Дополнительная защита:
```
if |a_measured| значительно отличается от 1g:
    → машина ускоряется → не доверять pitch из акселерометра
    → использовать только гироскоп (Madgwick с пониженным β)
```

---

## 7. Фаза 3: Управление дрифтом (Drift Assist)

### 7.1. Физика дрифта

**Дрифт** — управляемое скольжение задних колёс. Задняя ось теряет сцепление, машина движется боком:

```
       Вид сверху

     ───────────→  v (вектор скорости)
        ╱
       ╱ β (slip angle = угол между v и осью машины)
      ╱
     ║   ← ось машины (heading)
     ║
```

**Угол бокового скольжения (sideslip angle, β)**:
```
β = arctan(v_y / v_x)
```
где v_x, v_y — проекции скорости на оси кузова.

- β = 0° — машина едет прямо по своей оси
- β = 10-30° — управляемый дрифт
- β > 45° — потеря контроля (spin)

### 7.2. Bicycle Model (одноколёсная модель)

Упрощённая модель динамики автомобиля — два колеса (переднее и заднее) на продольной оси:

```
       δ (угол руля)
       ↗
      ● ← переднее колесо
      │
      │  L (колёсная база)
      │
      ● ← заднее колесо

      ───→ v (скорость)
```

**Уравнения движения** (в кузовной СК):

```
v̇_x = v_y · ω_z + a_x                              (продольная динамика)
v̇_y = -v_x · ω_z + (F_yf + F_yr) / m               (боковая динамика)
ω̇_z = (L_f · F_yf - L_r · F_yr) / I_z               (рыскание)
```

где:
- `F_yf`, `F_yr` — боковые силы передних и задних колёс
- `L_f`, `L_r` — расстояние от центра масс до передней и задней оси
- `I_z` — момент инерции вокруг вертикальной оси
- `m` — масса машины

### 7.3. Модель шин (линейная область)

Боковая сила пропорциональна углу увода (slip angle) колеса:

```
F_y = -C_α · α
```

где:
- `C_α` — **жёсткость увода** (cornering stiffness) [Н/рад]
- `α` — угол увода колеса (разница между направлением движения колеса и его ориентацией)

Углы увода:
```
α_f = δ - arctan((v_y + L_f · ω_z) / v_x)    (переднее колесо)
α_r = -arctan((v_y - L_r · ω_z) / v_x)         (заднее колесо)
```

**В дрифте** задние колёса выходят из линейной области — сила сцепления насыщается. Это даёт характерную нелинейную динамику.

### 7.4. Extended Kalman Filter (EKF)

Без датчика скорости колёс оцениваем состояние из IMU:

**Вектор состояния:**
```
x = [v_x, v_y, ω_z, β]^T
```

**Предсказание (prediction step):**

Используем bicycle model с известными входами (throttle → a_x, steer → δ):
```
x̂[k+1] = f(x̂[k], u[k]) · dt + x̂[k]
```

**Обновление (update step):**

Измерения от IMU:
```
z = [a_x, a_y, ω_z]_measured
```

Связь с состоянием:
```
a_x_pred = v̇_x + v_y · ω_z     (ускорение в кузовной СК включает кориолисово)
a_y_pred = v̇_y - v_x · ω_z
ω_z_pred = ω_z                   (прямое измерение)
```

Коррекция состояния по невязке:
```
K = P · H^T · (H · P · H^T + R)^{-1}     ← усиление Калмана
x̂ = x̂ + K · (z - h(x̂))                   ← обновлённая оценка
P = (I - K · H) · P                        ← обновлённая ковариация
```

**Вычислительная сложность**: матрицы 4×4 → ~200 float-операций на итерацию. На ESP32-S3 с FPU: **10-30 мкс** — укладывается в 2 мс цикла с огромным запасом.

### 7.5. Контроль дрифта

**Режим Normal (mode=0):** ω_z_desired = K · steer, β → 0 (подавление заноса)

**Режим Drift (mode=2):**
```
β_target = f(steer_command, throttle)    ← целевой угол заноса
e_β = β_target - β_estimated
u_steer = PID_yaw(ω_z_error) + PID_drift(e_β)
u_throttle = throttle_command + correction(e_β)
```

Стратегия:
- Малый газ + большой руль → вход в дрифт (увеличение β)
- Контрруление + газ → поддержание дрифта (стабилизация β)
- Сброс газа → выход из дрифта (уменьшение β к нулю)

### 7.6. Ограничения IMU-only оценки

Без датчиков скорости колёс:
- Оценка v_x/v_y дрейфует при интегрировании акселерометра
- EKF компенсирует через модель, но не идеально
- Наблюдаемость: при постоянной скорости без ускорения — нет информации о v

**Митигация:**
- Bicycle model constraint: физически невозможные состояния отсекаются
- Псевдо-измерение v=0 при остановке (ZUPT)
- В будущем: энкодеры на колёсах дадут прямое измерение v → EKF станет значительно точнее

---

## 8. Сводка: поток данных всей системы

```
IMU (MPU-6500, SPI, 500 Гц)
    │
    ▼
Калибровка (bias compensation)
    │
    ├───────────────────────────────┐
    │                               │
    ▼                               ▼
Madgwick AHRS                LPF Butterworth 2nd
    │                               │
    ├─► pitch, roll                 └─► ω_z_filtered
    │   (Фаза 2: компенсация)               │
    │                                       │
    └─► quaternion                          │
        (Фаза 3: EKF input)                 │
                                            │
    steer_command ──► Reference ──► e = ω_desired - ω_z_filtered
                        Model               │
                                            ▼
    throttle_command               ┌─────────────────┐
         │                         │   PID (Фаза 1)  │
         │                         │   Kp, Ki, Kd    │
         ▼                         └────────┬────────┘
    Pitch compensation                      │
    (Фаза 2)                                ▼
         │                          steer_correction
         ▼                                  │
    throttle_output                         ▼
         │                            steer_output
         │                                  │
         └──────────┬───────────────────────┘
                    │
                    ▼
              Slew Rate Limiter
                    │
                    ▼
              PWM Output (ESC + Servo)
```

---

## 9. Параметры для настройки

### Фильтрация (Фаза 0, реализовано)

| Параметр | Диапазон | Default | Описание |
|----------|----------|---------|----------|
| `madgwick_beta` | 0.01-1.0 | 0.1 | Усиление фильтра Madgwick |
| `lpf_cutoff_hz` | 5-100 | 30.0 | Частота среза LPF для gyro Z |

### Yaw Rate Control (Фаза 1, TODO)

| Параметр | Диапазон | Стартовое значение | Описание |
|----------|----------|--------------------|----------|
| `yaw_kp` | 0-2.0 | 0.3 | Пропорциональный коэффициент |
| `yaw_ki` | 0-0.5 | 0.0 | Интегральный (начать с 0) |
| `yaw_kd` | 0-0.5 | 0.05 | Дифференциальный |
| `yaw_max_correction` | 0-1.0 | 0.3 | Максимальная коррекция руля |
| `yaw_rate_scale` | 0-500 | 100.0 | K_steer: °/с на единицу руля |

### Pitch Compensation (Фаза 2, TODO)

| Параметр | Диапазон | Стартовое значение | Описание |
|----------|----------|--------------------|----------|
| `pitch_gain` | 0-1.0 | 0.3 | Коэффициент компенсации наклона |
| `pitch_max_correction` | 0-0.5 | 0.2 | Макс. коррекция газа от pitch |

### Drift Assist (Фаза 3, TODO)

| Параметр | Диапазон | Стартовое значение | Описание |
|----------|----------|--------------------|----------|
| `drift_kp` | 0-2.0 | 0.5 | PID по slip angle |
| `drift_ki` | 0-0.5 | 0.0 | |
| `drift_kd` | 0-0.5 | 0.1 | |
| `max_slip_angle_deg` | 0-60 | 35.0 | Ограничение угла заноса |
| `wheelbase_m` | 0.1-0.5 | 0.26 | Колёсная база |
| `mass_kg` | 0.5-5.0 | 2.0 | Масса машины |

---

## 10. Процедура настройки (Tuning Guide)

### Шаг 1: Проверка фильтрации (Фаза 0)

1. Поставить машину на ровную поверхность
2. Подключиться к телеметрии через WebSocket
3. Убедиться, что pitch ≈ 0, roll ≈ 0 (± 1-2°)
4. Повращать машину рукой → yaw должен меняться плавно
5. Включить мотор на холостом ходу → gyro_z_filtered не должен показывать ложные вращения
6. Если шум > 2 °/с — уменьшить `lpf_cutoff_hz` до 20 Гц

### Шаг 2: Настройка Yaw Rate PID (Фаза 1)

**Метод Зиглера-Никольса (упрощённый):**

1. Ki = 0, Kd = 0
2. Увеличивать Kp от 0, пока не появятся колебания руля → это K_u (критическое усиление)
3. Kp = 0.45 · K_u
4. Добавить Kd = 0.05 · Kp — проверить, стали ли манёвры стабильнее
5. Ki добавлять только если есть постоянный увод

**Практический метод:**

1. `yaw_kp = 0.1, yaw_ki = 0, yaw_kd = 0`
2. Ехать прямо и резко дать руль → машина должна слегка сопротивляться повороту
3. Увеличивать Kp по 0.05, пока сопротивление не станет ощутимым
4. Если руль дрожит → уменьшить Kp, добавить Kd = 0.02-0.05
5. Если машину тянет в сторону при прямой езде → добавить Ki = 0.01-0.05

### Шаг 3: Проверка безопасности

1. Выключить стабилизацию → машина должна работать как раньше, без рывков
2. Включить обратно → переход плавный
3. Потеря связи → failsafe нейтрализует все выходы
4. `max_correction = 0.3` → даже при неправильных PID-коэффициентах руль не дёрнет сильнее 30%

---

## 11. Модель шин: от линейной к Pacejka

### 11.1. Почему модель шин критична

Вся динамика машины определяется силами в пятне контакта шины с поверхностью. Без понимания шин невозможно:
- Предсказать момент срыва в занос
- Корректно настроить EKF для drift assist
- Понять, почему машина ведёт себя нелинейно

### 11.2. Линейная модель (малые углы увода)

При малых углах увода (|α| < 3-5°) боковая сила **линейна**:

```
F_y = -C_α · α
```

Это хорошее приближение для обычного вождения. `C_α` зависит от:
- Типа покрытия (асфальт: C_α высокий, лёд: C_α низкий)
- Давления в шинах
- Вертикальной нагрузки на колесо

Для RC-машины на асфальте: C_α ≈ 5-15 Н/рад (масштаб ~1:10).

### 11.3. Нелинейная модель Pacejka ("Magic Formula")

При больших углах увода (дрифт, экстремальные манёвры) сила **насыщается**:

```
F_y(α) = D · sin(C · arctan(B·α - E·(B·α - arctan(B·α))))
```

где:
- **B** — фактор жёсткости (stiffness factor): наклон кривой при α → 0
- **C** — фактор формы (shape factor): определяет форму кривой (≈ 1.3 для боковой силы)
- **D** — пиковая сила (peak force): D = μ · F_z (коэффициент трения × вертикальная нагрузка)
- **E** — фактор кривизны (curvature factor): асимметрия кривой

**График F_y(α):**
```
F_y
 ▲
 │        ╭───────────  D (пиковая сила)
 │      ╱╱
 │    ╱╱     ← линейная область (F_y ≈ -C_α · α)
 │  ╱╱
 │╱╱
─┼──────────────────────► α (угол увода)
 │           ▲
 │         α_peak ≈ 8-12°
 │
 │    после пика: сила ПАДАЕТ → нестабильность → дрифт
```

**Ключевой момент**: после пика (α > α_peak) сила сцепления **уменьшается** при дальнейшем увеличении угла увода. Это создаёт положительную обратную связь:
1. Задние колёса скользят → α_r растёт
2. F_yr уменьшается → меньше боковой силы → ещё больше скольжения
3. Без коррекции → неконтролируемый разворот (spin)

Задача drift assist — удерживать α_r в зоне **после пика, но до потери контроля** (10-35°).

### 11.4. Упрощённая модель для ESP32

Полная Pacejka вычислительно дешёвая (1-2 мкс), но требует идентификации 4+ параметров. Для RC-машины удобнее **кусочно-линейная аппроксимация**:

```
         ┌ -C_α · α,                          |α| ≤ α_peak
F_y(α) = ┤
         └ -sign(α) · D · (1 - k · (|α| - α_peak)),  |α| > α_peak
```

где:
- `α_peak` ≈ 8-12° — угол пиковой силы
- `D` = μ · F_z — пиковая сила
- `k` ≈ 0.01-0.05 — скорость падения силы после пика

Параметры `α_peak`, `D`, `k` определяются экспериментально: машина делает серию манёвров с нарастающей агрессивностью, по телеметрии (ω_z, a_y, steer) восстанавливаются характеристики.

### 11.5. Перенос нагрузки (Load Transfer)

При торможении/разгоне и поворотах вертикальная нагрузка на колёса перераспределяется:

**Продольный перенос (торможение/разгон):**
```
ΔF_z_longitudinal = m · a_x · h_cg / L
```
- Торможение: нагрузка на передние колёса растёт → F_yf_max растёт
- Разгон: нагрузка на задние колёса падает → F_yr_max падает → **склонность к заносу**

**Поперечный перенос (поворот):**
```
ΔF_z_lateral = m · a_y · h_cg / track_width
```
- Внешние колёса нагружаются, внутренние разгружаются

где:
- `h_cg` — высота центра масс (~30-50 мм для RC 1:10)
- `track_width` — ширина колеи (~200 мм)
- `L` — колёсная база (~260 мм)

Для RC-машины h_cg/L ≈ 0.15 — перенос нагрузки заметен, особенно при резком разгоне заднеприводной машины.

---

## 12. Анализ устойчивости замкнутого контура

### 12.1. Замкнутая система с PID

Контур yaw rate control — классическая SISO (single input, single output) система:

```
                    ┌──────────────────────┐
steer_cmd ──►(+)──►│  G_plant(s)          │──► ω_z
              ▲    │  (машина + шины)     │
              │    └──────────────────────┘
              │              │
              │    ┌─────────┴──────────┐
              └────│  C_pid(s) · G_lpf(s)│◄── ω_z_measured
                   │  (PID + фильтр)    │
                   └────────────────────┘
```

**Передаточная функция разомкнутого контура:**
```
L(s) = C_pid(s) · G_lpf(s) · G_plant(s)
```

### 12.2. Модель объекта управления (Plant)

Для yaw rate: входной сигнал — коррекция руля, выход — ω_z.

Упрощённая модель 1-го порядка:
```
G_plant(s) = K_plant / (τ_plant · s + 1)
```

где:
- `K_plant` — статический коэффициент усиления (°/с на единицу руля), зависит от скорости
- `τ_plant` — постоянная времени (~50-200 мс): определяется инерцией машины и жёсткостью увода шин

```
τ_plant = I_z / (L_f² · C_αf + L_r² · C_αr)    [с]
```

Чем тяжелее машина и мягче шины → тем больше τ → тем медленнее реакция.

### 12.3. Передаточная функция PID

```
C_pid(s) = Kp + Ki/s + Kd·s
```

С фильтром D-члена (N — коэффициент фильтрации, обычно 10-20):
```
C_pid(s) = Kp + Ki/s + Kd·s·N / (s + N)
```

### 12.4. Влияние LPF на устойчивость

Butterworth 2-го порядка добавляет фазовый запаздывание:

```
G_lpf(s) = ω_c² / (s² + √2·ω_c·s + ω_c²),    ω_c = 2π·f_c
```

Фазовый сдвиг на частоте среза: -90°. На удвоенной частоте: -135°.

**Критично**: LPF уменьшает запас по фазе замкнутой системы. Если PID настроен агрессивно (большой Kp), LPF может привести к нестабильности.

### 12.5. Запас устойчивости

Для стабильности замкнутого контура нужно:

**Запас по фазе (Phase Margin):** PM > 30° (желательно 45-60°)
```
PM = 180° + arg[L(jω_gc)]
```
где ω_gc — частота среза (|L(jω_gc)| = 1).

**Запас по амплитуде (Gain Margin):** GM > 6 дБ (желательно > 10 дБ)
```
GM = -20·log₁₀|L(jω_pc)|
```
где ω_pc — частота, при которой фаза = -180°.

### 12.6. Практическая проверка устойчивости

Без аналитических инструментов на ESP32 проверяем эмпирически:

1. **Тест на колебания**: постучать по машине (импульс). Если ω_z осциллирует и затухает за 2-3 периода — нормально. Если не затухает — Kp слишком велик.

2. **Тест на ступеньку**: резко дать руль из нейтрали. Ответ должен быть:
   - Без overshoot > 20% — хороший запас по фазе
   - Время установления < 200 мс — достаточная полоса пропускания
   - Без устойчивых колебаний

3. **Признаки нестабильности**:
   - Руль дрожит с частотой 5-15 Гц → снизить Kp или Kd
   - Медленные колебания 1-3 Гц → снизить Ki
   - Рывки при включении/выключении → нет плавного перехода (ramping)

---

## 13. Бюджет задержек (Latency Budget)

### 13.1. Путь сигнала

```
Физическое вращение → датчик → SPI → калибровка → LPF → PID → PWM → сервопривод → колёса
```

### 13.2. Детальный разбор

| Этап | Задержка | Тип | Примечание |
|------|----------|-----|------------|
| **IMU внутренний** | 2.0 мс | Фиксированная | Внутренний ADC + цифровой фильтр MPU-6500 |
| **SPI передача** | 0.02 мс | Фиксированная | 14 байт @ 10 МГц |
| **Калибровка** | 0.001 мс | Фиксированная | Вычитание bias (3 вычитания) |
| **LPF Butterworth** | 7.5 мс | Частотно-зависимая | Групповая задержка при f_c = 30 Гц |
| **PID вычисление** | 0.005 мс | Фиксированная | ~20 float-операций |
| **Квантование по времени** | 1.0 мс | Стохастическая | В среднем dt/2 при 500 Гц |
| **PWM обновление** | 0.02 мс | Фиксированная | MCPWM регистр |
| **Сервопривод** | 5-20 мс | Механическая | Зависит от хода и нагрузки |
| **Шина реагирует** | 10-50 мс | Механическая | Зависит от скорости и покрытия |

### 13.3. Итого

```
Минимальная задержка ≈ 2 + 0.02 + 7.5 + 1 + 5 ≈ 16 мс (электронная + серво)
Типичная задержка ≈ 16 + 20 ≈ 36 мс (с учётом механики шин)
Максимальная задержка ≈ 16 + 50 ≈ 66 мс (медленный серво + мягкие шины)
```

### 13.4. Влияние на PID

Задержка = "мёртвое время" (dead time) в контуре. Чем больше задержка → тем ниже предельная полоса пропускания контура:

```
ω_bandwidth_max ≈ 1 / (3 · τ_delay)
```

Для τ_delay = 36 мс:
```
f_bandwidth ≈ 1 / (3 · 0.036) ≈ 9 Гц
```

Это значит: PID не может корректировать колебания быстрее ~9 Гц. Манёвры RC-машины — 1-5 Гц → запас достаточный.

### 13.5. Оптимизация задержки

Главные источники задержки, которые можно контролировать:

| Источник | Текущее | Оптимизация | Эффект |
|----------|---------|-------------|--------|
| LPF | 7.5 мс | Увеличить f_c до 50 Гц | 4.5 мс (-3 мс) |
| Квантование | 1.0 мс | Увеличить частоту до 1000 Гц | 0.5 мс (-0.5 мс) |
| Серво | 10-20 мс | Цифровой серво с высоким refresh rate | 3-5 мс (-10 мс) |

Самый большой выигрыш — от быстрого сервопривода. LPF задержку можно снизить ценой шума.

---

## 14. Шумовые характеристики MPU-6500

### 14.1. Паспортные характеристики

| Параметр | Значение | Единицы |
|----------|----------|---------|
| Gyro noise density | 0.005 | °/с/√Гц |
| Gyro bias stability | ±5 | °/ч |
| Gyro temperature drift | ±0.03 | °/с/°C |
| Accel noise density | 300 | μg/√Гц |
| Accel bias | ±60 | mg |

### 14.2. RMS-шум гироскопа

При полосе пропускания B_w [Гц]:
```
σ_gyro = noise_density · √(B_w)     [°/с]
```

| Полоса (B_w) | σ_gyro | Применение |
|--------------|--------|------------|
| 30 Гц (LPF f_c) | 0.027 °/с | После LPF — это наш рабочий шум |
| 100 Гц | 0.05 °/с | Без LPF |
| 250 Гц | 0.08 °/с | На полной полосе IMU |

0.027 °/с после LPF — отличный результат. Для сравнения: типичный манёвр даёт ω_z = 30-200 °/с → SNR > 1000:1.

### 14.3. Влияние вибраций

На практике главный источник шума — не электроника, а **механические вибрации**:

| Источник | Частота | Амплитуда | Митигация |
|----------|---------|-----------|-----------|
| Мотор (щёточный) | 50-300 Гц | 1-10 °/с | LPF (f_c < 50 Гц) |
| Подвеска | 5-20 Гц | 0.5-5 °/с | Частично LPF, частично полезный сигнал |
| Неровности дороги | 1-10 Гц | 1-20 °/с | Полезный сигнал (не фильтровать!) |
| Дисбаланс колёс | 10-30 Гц | 0.5-3 °/с | LPF |

**Критично**: вибрации мотора на 50-200 Гц — главный враг. LPF с f_c = 30 Гц подавляет их на -21 дБ (в 11 раз). Если недостаточно, добавить:
- Механическую виброизоляцию (поролон, силиконовые демпферы)
- Снижение f_c до 20 Гц (ценой задержки)

### 14.4. Allan Variance и долгосрочная стабильность

Bias гироскопа дрейфует со временем и температурой. Характеристики:

```
Angle Random Walk (ARW) = noise_density = 0.005 °/с/√Гц
Bias Instability = 5 °/ч = 0.0014 °/с
```

Для **yaw rate control** (Фаза 1): bias instability не критична, т.к. мы работаем с ω_z напрямую, а не интегрируем в угол. Bias калибруется при старте и компенсируется ZUPT.

Для **drift assist** (Фаза 3): при интегрировании ω_z для оценки heading в EKF, bias instability даёт дрейф ~5°/мин. EKF компенсирует через модель, но при длительном дрифте (> 30 с) точность heading деградирует. На практике дрифт-сессии < 10 с → приемлемо.

---

## 15. Динамика переходных процессов

### 15.1. Включение/выключение стабилизации

При резком включении PID возникнет скачок выходного сигнала (derivative kick). Решение — **bumpless transfer**:

```
При включении стабилизации:
    I_integral = 0                ← обнулить интеграл
    ω_z_prev = ω_z_current       ← инициализировать D-историю
    correction = 0                ← начать с нулевой коррекции
    ramping_factor = 0            ← плавное нарастание

На каждом шаге (первые 250 мс после включения):
    ramping_factor += dt / ramp_time     (ramp_time = 250 мс)
    ramping_factor = min(ramping_factor, 1.0)
    u_output = u_pid * ramping_factor
```

При выключении — симметричный ramp-down за 100 мс (быстрее, чем включение, чтобы оператор сразу почувствовал прямое управление).

### 15.2. Переключение режимов (Normal → Sport → Drift)

Каждый режим имеет свой набор PID-параметров:

| Параметр | Normal | Sport | Drift |
|----------|--------|-------|-------|
| `yaw_kp` | 0.3 | 0.15 | 0.1 |
| `yaw_ki` | 0.0 | 0.0 | 0.0 |
| `yaw_kd` | 0.05 | 0.03 | 0.02 |
| `max_correction` | 0.3 | 0.2 | 0.15 |
| `lpf_cutoff_hz` | 30 | 40 | 50 |

**Normal**: максимальная стабилизация, подавление любого заноса.
**Sport**: ослабленная стабилизация, позволяет контролируемые заносы.
**Drift**: минимальная стабилизация yaw, активный drift assist.

Переход между режимами — **интерполяция параметров за 500 мс**:
```
param(t) = param_old + (param_new - param_old) · ramp(t)
```

Это предотвращает скачки PID-выхода при переключении.

### 15.3. Failsafe при сбое стабилизации

Сценарии сбоя и реакция:

| Сбой | Детекция | Действие |
|------|----------|----------|
| IMU не отвечает | ReadImu() = nullopt 3 раза подряд | Выключить стабилизацию, прямое управление |
| NaN в фильтре | isnan(ω_z_filtered) | Reset фильтров, обнулить PID, перезапуск |
| PID расходится | |u| = max_correction > 100 мс | Снизить Kp на 50%, логировать |
| Калибровка невалидна | bias > 20 °/с | Перекалибровка при остановке |

Принцип: при любом сбое стабилизации машина должна вести себя как без стабилизации (прямая передача команд), а не терять управление.

---

## 16. Частотный анализ контура управления

### 16.1. Спектр типичных маневров

Анализ частотного содержания команд и реакций RC-машины:

| Маневр | Частотный диапазон | Амплитуда ω_z |
|--------|--------------------|---------------|
| Плавный поворот | 0.2-1 Гц | 10-50 °/с |
| Быстрая смена направления | 1-3 Гц | 30-100 °/с |
| Коррекция заноса | 2-5 Гц | 50-200 °/с |
| Вибрация руля (нежелательная) | 5-15 Гц | 1-5 °/с |
| Мех. вибрации шасси | 10-50 Гц | 0.5-10 °/с |
| Мотор | 50-300 Гц | 1-20 °/с |

**Полоса пропускания контура** должна быть 5-10 Гц: достаточно для коррекции заносов, но не усиливать вибрации.

### 16.2. Диаграмма Боде контура

Типичная картина для правильно настроенного контура:

```
Амплитуда |L(jω)| [дБ]
  20 ┤
     │╲
  10 ┤  ╲
     │    ╲     ← PID + Plant
   0 ┤──────╲──────── ω_gc (частота среза ≈ 8 Гц)
     │        ╲
 -10 ┤          ╲╲   ← LPF начинает подавлять
     │            ╲╲
 -20 ┤              ╲╲╲
     │                ╲╲╲
 -40 ┤
     └─────┬─────┬─────┬────► f [Гц]
           1     10    100

Фаза arg[L(jω)] [°]
   0 ┤──────╮
     │       ╲
 -45 ┤        ╲
     │         ╲
 -90 ┤          ╲
     │           ╲    ← LPF добавляет фазу
-135 ┤            ╲╲
     │              ╲╲
-180 ┤─ ─ ─ ─ ─ ─ ─ ─╲─ ─ ─ ← граница устойчивости
     └─────┬─────┬─────┬────► f [Гц]
           1     10    100

PM = 180° - |фаза на ω_gc| ≈ 50-60° (хороший запас)
```

### 16.3. Конфликт фильтрации и быстродействия

Фундаментальный компромисс:

```
                      ┌─────────────────────────────────────────┐
                      │                                         │
  Больше фильтрации ──┤── меньше шума, глаже управление        │
  (f_c ↓)             │── больше фазовый запаздывание           │
                      │── меньше полоса пропускания             │
                      │── меньше запас устойчивости             │
                      └─────────────────────────────────────────┘

                      ┌─────────────────────────────────────────┐
                      │                                         │
  Меньше фильтрации ──┤── быстрее реакция                     │
  (f_c ↑)             │── больше запас устойчивости             │
                      │── больше шума → дрожание серво          │
                      │── больше нагрузка на механику           │
                      └─────────────────────────────────────────┘
```

**Оптимум для RC-машины**: f_c = 20-40 Гц. Конкретное значение определяется уровнем вибраций конкретного шасси.

---

## 17. Оценка скорости без датчика (IMU-only)

### 17.1. Проблема

У нас нет энкодеров на колёсах → нет прямого измерения скорости. Но скорость нужна для:
- Масштабирования ω_z_desired (Фаза 1)
- Bicycle model в EKF (Фаза 3)
- Оценки slip angle (Фаза 3)

### 17.2. Интегрирование акселерометра

Наивный подход:
```
v(t) = v(0) + ∫ a(τ) dτ
```

**Проблема**: bias акселерометра 60 mg = 0.59 м/с² → за 1 секунду ошибка скорости = 0.59 м/с. За 10 секунд = 5.9 м/с. Неприемлемо.

### 17.3. Практические подходы

**A) Псевдо-измерение скорости по throttle:**
```
v_estimate = K_throttle · throttle_command    (грубая оценка)
```
Коэффициент K_throttle определяется экспериментально. Не учитывает склон, покрытие, буксование — но для масштабирования ω_z_desired в Фазе 1 достаточно.

**B) ZUPT (Zero-velocity Update):**

При обнаружении неподвижности (var(ω) < порог && var(a) < порог):
```
v = 0    (принудительный сброс)
```
Это ограничивает рост ошибки интегрирования: каждая остановка "обнуляет" дрейф.

**C) Модельное ограничение (Фаза 3, EKF):**

Bicycle model + физические ограничения:
```
v_x > 0 (машина не едет задним ходом, если throttle > 0)
|v_y| < v_x · tan(45°) (боковая скорость не может быть больше продольной)
v < v_max (физический предел для данной машины)
```

EKF использует эти ограничения как "мягкие измерения", не давая скорости уйти в нефизичные значения.

**D) Кулоновская модель (Фаза 3, улучшенная):**
```
m · v̇_x = F_throttle(throttle) - F_drag(v) - F_roll
```
где:
- F_throttle — тяга мотора (известна из команды газа + характеристика мотора)
- F_drag = ½ρCdA·v² — аэродинамическое сопротивление (мало для RC на малых скоростях)
- F_roll = μ_roll · m · g — сопротивление качению

Интегрируя эту модель и корректируя по a_x от IMU, получаем более точную оценку v.

---

## 18. Энергетический анализ и физические пределы

### 18.1. Максимальная угловая скорость

Определяется сцеплением шин:
```
ω_z_max = μ · g / v     [рад/с]
```

| Скорость v | μ = 0.8 (асфальт) | μ = 0.3 (грязь) |
|------------|-------------------|-----------------|
| 2 м/с | 3.9 рад/с (224 °/с) | 1.5 рад/с (84 °/с) |
| 5 м/с | 1.6 рад/с (90 °/с) | 0.6 рад/с (34 °/с) |
| 10 м/с | 0.8 рад/с (45 °/с) | 0.3 рад/с (17 °/с) |

Важно: PID не может превысить физический предел — если шины скользят, никакая коррекция руля не поможет. Safety limit `max_correction = 0.3` гарантирует, что стабилизация не сделает хуже.

### 18.2. Минимальный радиус поворота

Без скольжения (кинематика Аккермана):
```
R_min = L / tan(δ_max)
```

Для L = 260 мм, δ_max = 30°:
```
R_min = 260 / tan(30°) ≈ 450 мм
```

При скольжении (динамика) радиус может быть меньше — за счёт бокового скольжения задних колёс (дрифт).

### 18.3. Критическая скорость

Скорость, при которой машина переходит от недостаточной к избыточной поворачиваемости:
```
v_critical = √(L · C_αf · C_αr / (m · (C_αr · L_r - C_αf · L_f)))
```

Если `C_αr · L_r < C_αf · L_f` → машина всегда имеет избыточную поворачиваемость (типично для заднеприводных RC). В этом случае критической скорости нет — машина склонна к заносу на любой скорости при резких манёврах.

---

## 19. Резюме: что реализовано и что предстоит

### Реализовано (Фаза 0)

| Компонент | Физика | Статус |
|-----------|--------|--------|
| IMU чтение 500 Гц | Измерение ω и a | Готово, протестировано |
| Калибровка bias | Компенсация систематической ошибки датчиков | Готово, двухэтапная |
| Madgwick AHRS | Fusion гироскопа и акселерометра через кватернионы | Готово, 70+ тестов |
| LPF Butterworth | Подавление шума выше f_c с максимально плоской АЧХ | Готово, 60+ тестов |
| Конфигурация | Параметризация всех фильтров | Готово, NVS + WebSocket |

### Предстоит (Фазы 1-3)

| Компонент | Физика | Сложность |
|-----------|--------|-----------|
| **PID yaw rate** | Обратная связь по ω_z, reference model | Средняя |
| **Pitch compensation** | Проекция гравитации на ось движения | Низкая |
| **Tire model** | Pacejka / кусочно-линейная аппроксимация | Средняя |
| **EKF** | Байесовская фильтрация, bicycle model | Высокая |
| **Drift controller** | Многоканальный PID + EKF состояния | Высокая |

### Порядок реализации

```
Фаза 1 (ближайшая):
    PID controller class → integration в control loop → tuning → тесты

Фаза 2 (после Фазы 1):
    Pitch/roll из Madgwick → throttle correction → тесты на склоне

Фаза 3 (после Фазы 2):
    Tire model → EKF → drift PID → интеграция → тесты дрифта
```
